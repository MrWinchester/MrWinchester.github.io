---
layout:     post
title:      "设计模式"
date:       2018-04-10 22:49:00
description: "设计模式"
tag :      [设计模式,design pattern]
---

# 设计模式
* 单例模式
  * 懒汉式-双重校验锁
  ```
  public class Singleton {

    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {  //1
            synchronized (Singleton.class) {
                if (uniqueInstance == null) { //2
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
  }
  ```
  * 如果没有第二层的循环可以吗?
    * 答案：不行，多线程并发的时候，虽然会在if锁住，但是后面都会执行new Singleton()，导致实例化多次
  * 如果没有第一层循环可以吗?
    * 答案：不行，因为每次取getUniqueInstance，都会加锁阻塞，导致性能有一定损耗。
  * volatile可以省略吗?
    * 答案：不行，volatile有两个功能，1.确保共享变量再多线程环境下的可见性 2.禁止JVM指令重排序 `uniqueInstance = new Singleton();`并不是原子性动作，new对象分为3个动作：(1)分配内存空间。(2)初始化对象。(3)将 uniqueInstance 指向分配的内存地址。
    * 指令重排序：一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。new对象的三个动作由于没有`前后依赖关系`，所以有可能执行顺序是123，也有可能是132，如果是132，多线程环境下，若此时恰好有线程B获取实例，就有可能获取到一个还没有被初始化的对象导致报错。


  * 每日一更，持续更新中......
  参考自[设计模式](https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md)
